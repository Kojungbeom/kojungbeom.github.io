<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jekyll Gitbook</title><subtitle>Build Jekyll site with the GitBook style.
</subtitle><author><name>HE Tao</name></author><entry><title type="html"></title><link href="http://localhost:4000/2022-12-17-2022-12-17-LeetCode-3.-Longest-Substring-Without-Repeating-Characters-JB.html" rel="alternate" type="text/html" title="" /><published>2022-12-17T15:29:59+09:00</published><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/2022-12-17-%5BLeetCode%5D-3.-Longest-Substring-Without-Repeating-Characters-JB</id><content type="html" xml:base="http://localhost:4000/2022-12-17-2022-12-17-LeetCode-3.-Longest-Substring-Without-Repeating-Characters-JB.html"><![CDATA[<h1 id="leetcode-3-longest-substring-without-repeating-characters">[LeetCode] 3. Longest Substring Without Repeating Characters</h1>

<p><code class="language-plaintext highlighter-rouge">LeetCode</code> 3번 문제를 풀어보았다.. <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">Link</a></p>

<h1 id="problem">Problem</h1>

<p>Given a string <code class="language-plaintext highlighter-rouge">s</code>, find the length of the <strong>longest</strong> <strong>substring</strong> without repeating characters.</p>

<h1 id="intuition">Intuition</h1>

<p>Substring이 시작하는 곳을 <code class="language-plaintext highlighter-rouge">start</code>, 끝나는 곳을 <code class="language-plaintext highlighter-rouge">end</code>라고 할 때, <code class="language-plaintext highlighter-rouge">start</code>와 <code class="language-plaintext highlighter-rouge">end</code> 를 움직여가며 조건(without repeating characters)에 충족하는 모든 Substring의 길이를 비교하여 그 중 가장 긴 길이를 출력하면 될거라고 생각했다.</p>

<p>놀랍게도 처음에 풀 때는 그냥 수월하게 풀었는데 다시 풀 때 더 시간이 오래 걸렸다. 체계적인 복습이 중요하다..</p>

<h1 id="approach">Approach</h1>

<p>모든 케이스를 전부 비교하는 Brute Force 알고리즘으로 풀었다.</p>

<ol>
  <li>s[start:end] 안에 s[end]가 있는지 확인한다.
    <ol>
      <li>없으면 그때의 s[start:end]의 길이를 측정하고, max_length와 비교한다.
        <ol>
          <li>max_length보다 작으면 end point를 한칸 옮긴다.</li>
          <li>max_length보다 크면 max_length를 end - start + 1로 update한다.</li>
        </ol>
      </li>
      <li>있으면 max_length를 비교한다.
        <ol>
          <li>max_length보다 크면 max_length를 end - start로 update한다.</li>
          <li>start point를 한칸 옮긴다.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>start point가 len(s)-1에 도달할 때 까지 반복한다.</li>
</ol>

<h1 id="complexity">Complexity</h1>
<ul>
  <li>
    <p>Time complexity:</p>

    <p>이중 for loop로, \(O(n^2)\)라고 착각할 수 있지만, 문자열 Slice와의 비교가 있기 때문에 \(O(n^3)\)이다.</p>

    <p>(이건 정확하지 않음..)</p>
  </li>
  <li>
    <p>Space complexity:
문자열에 중복 문자가 없는지 확인하는데는 \(O(n)\)이 필요하다.</p>
  </li>
</ul>

<h1 id="my-code">My Code</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="s">"""
        Input: A string "s"
        Output: The length or the longest substring without repeating characters.
        """</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">max_length</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">max_length</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">max_length</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">:</span>
                        <span class="n">max_length</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">max_length</span>
</code></pre></div></div>

<h1 id="others">Others</h1>

<p>Brute force을 사용한 내 풀이보다 더 효율적인 방법으로 최적화한 코드이다.</p>

<p>아이디어는 다음과 같다.</p>

<ul>
  <li>예를들어 “abcade”가 있다고 했을 때, 기존의 Brute force 알고리즘으로 처리한다면 “abc”, “a”에서 멈추게 된다.</li>
  <li>이때 굳이 나머지 “de”를 다 본 다음 새로운 start와 end point를 “b”, “c”로 옮기는 것이 아니라 중복이 없는 선까지 start point만 옮기는 방법을 사용한다. (코드와 함께보면 이해할 수 있을까?)</li>
  <li>또한 여기서 필요없는 search algorithm을 피하기 위해 Hash map (python에서는 Dictionary)를 활용한다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addTwoNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">len_s</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">Mlength</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">len_s</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">Mlength</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Mlength</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nb">dict</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">Mlength</span>
</code></pre></div></div>

<ul>
  <li>이 Approach의 Time complexity는 한 반복(end) 안에 끝나기 때문에 \(O(n)\)이다.</li>
  <li>Space complexity도 Dictionary에 저장하는 공간을 생각하면 \(O(max(n, m))\)이다.</li>
</ul>]]></content><author><name>HE Tao</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2022-12-17-2022-12-17-LeetCode-2.-Add-Two-Number-JB.html" rel="alternate" type="text/html" title="" /><published>2022-12-17T15:29:59+09:00</published><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/2022-12-17-%5BLeetCode%5D-2.-Add-Two-Number-JB</id><content type="html" xml:base="http://localhost:4000/2022-12-17-2022-12-17-LeetCode-2.-Add-Two-Number-JB.html"><![CDATA[<h1 id="leetcode-2-add-two-number">[LeetCode] 2. Add Two Number</h1>

<p><code class="language-plaintext highlighter-rouge">LeetCode</code> 2번 문제를 풀어보았다.. <a href="https://leetcode.com/problems/add-two-numbers/description/">Link</a></p>

<h1 id="problem">Problem</h1>

<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>양수로 채워진 두개의 Linked list가 주어진다. 숫자들은 역순으로 저장되고, 각 노드에는 단일 숫자가 포함된다. 두 숫자의 합계를 Linked list으로 Return하라.</p>

<h1 id="intuition">Intuition</h1>

<p>어떤 특수한 알고리즘 사용이 필요하다기 보다는 Linked list Class의 특성을 이해하고 이를 코드로 옮기는 것이 중요하다고 생각했다.</p>

<h1 id="approach">Approach</h1>
<ol>
  <li>
    <p>각 Linked list <code class="language-plaintext highlighter-rouge">l1</code>, <code class="language-plaintext highlighter-rouge">l2</code>의 각 노드의 단일 숫자들에 접근하여 숫자로 만든다.</p>

    <ul>
      <li>Example) <code class="language-plaintext highlighter-rouge">l1</code> = [2,4,3]이면 342로 만든다.</li>
    </ul>
  </li>
  <li>
    <p>두 숫자를 더한다음 <code class="language-plaintext highlighter-rouge">String</code> 타입으로 바꾸고 역순으로 변환한다.</p>
  </li>
  <li>
    <p>첫번째 노드를 만든다.</p>
  </li>
  <li>
    <p>반복문으로 다음 노드를 만들고 이전 노드의 <code class="language-plaintext highlighter-rouge">next</code>에 연결한다.</p>
  </li>
  <li>
    <p>Linked list를 Return한다.</p>
  </li>
</ol>

<h1 id="complexity">Complexity</h1>
<ul>
  <li>
    <p>Time complexity:</p>

    <p><code class="language-plaintext highlighter-rouge">l1</code> 과 <code class="language-plaintext highlighter-rouge">l2</code>의 길이를 각각 <code class="language-plaintext highlighter-rouge">n</code>, <code class="language-plaintext highlighter-rouge">m</code>이라고 하면, <code class="language-plaintext highlighter-rouge">sum_l1</code>을 구하는데 \(O(n)\), <code class="language-plaintext highlighter-rouge">sum_l2</code>를 구하는데 \(O(m)\), 그리고 새로운 Linked list를 만드는데 \(O(max(n, m)) or O(max(n, m)) +1\)으로, 정리하면 \(O(max(n, m))\) 이다.</p>
  </li>
  <li>
    <p>Space complexity:
새 Linked list의 길이는 최대 max(n, m) + 1로, \(O(max(n, m))\)이다</p>
  </li>
</ul>

<h1 id="my-code">My Code</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addTwoNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="s">"""
        Input: two non-empty linked lists
        Output: the sum of the two numbers as a linked list
        Caution: The digits are stored in reverse order
        """</span>
        <span class="n">sum_l1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">digit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">l1</span><span class="p">:</span>
            <span class="n">sum_l1</span> <span class="o">+=</span> <span class="n">digit</span> <span class="o">*</span> <span class="n">l1</span><span class="p">.</span><span class="n">val</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">digit</span> <span class="o">*=</span> <span class="mi">10</span>

        <span class="n">sum_l2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">digit</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">l2</span><span class="p">:</span>
            <span class="n">sum_l2</span> <span class="o">+=</span> <span class="n">digit</span> <span class="o">*</span> <span class="n">l2</span><span class="p">.</span><span class="n">val</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">digit</span> <span class="o">*=</span> <span class="mi">10</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="n">sum_l1</span> <span class="o">+</span> <span class="n">sum_l2</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">base</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">while</span> <span class="n">t</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">t</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">temp</span>
        
        <span class="k">return</span> <span class="n">base</span>
</code></pre></div></div>

<h1 id="others">Others</h1>

<p>내 풀이와 다르게 하나의 반복문에서 모든 처리를 하는 코드이다. <code class="language-plaintext highlighter-rouge">l1</code>과 <code class="language-plaintext highlighter-rouge">l2</code>의 길이 차이를 <code class="language-plaintext highlighter-rouge">if .. else..</code>문으로 해결하였다.</p>

<p>또한 특정 자리의 숫자를 계산함과 동시에 Single digit으로 치환 후 새로운 Node로 만들어 바로 Linked list에 붙인다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addTwoNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummyHead</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">dummyHead</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">l1</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">l2</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">carry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">l1Val</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">l1</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">l2Val</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">l2</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">columnSum</span> <span class="o">=</span> <span class="n">l1Val</span> <span class="o">+</span> <span class="n">l2Val</span> <span class="o">+</span> <span class="n">carry</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">columnSum</span> <span class="o">//</span> <span class="mi">10</span>
            <span class="n">newNode</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">columnSum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">newNode</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">newNode</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="p">.</span><span class="nb">next</span> <span class="k">if</span> <span class="n">l1</span> <span class="k">else</span> <span class="bp">None</span>
            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="nb">next</span> <span class="k">if</span> <span class="n">l2</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">dummyHead</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>]]></content><author><name>HE Tao</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2022-12-17-2022-12-09-JB9.html" rel="alternate" type="text/html" title="" /><published>2022-12-17T15:29:59+09:00</published><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/2022-12-09-JB9</id><content type="html" xml:base="http://localhost:4000/2022-12-17-2022-12-09-JB9.html"><![CDATA[<h1 id="백준-빗물-14719번">[백준] 빗물 #14719번</h1>

<p><a href="https://www.acmicpc.net/problem/14719">Link</a></p>

<h2 id="문제"><u>문제</u></h2>

<p>2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.</p>

<p>비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?</p>

<h2 id="입력"><u>입력</u></h2>

<p>첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)</p>

<p>두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.</p>

<p>따라서 블록 내부의 빈 공간이 생길 수 없다. 또 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.</p>

<h2 id="출력"><u>출력</u></h2>

<p>2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.</p>

<p>빗물이 전혀 고이지 않을 경우 0을 출력하여라.</p>

<h2 id="예제-입력-1"><u>예제 입력 1</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 4
3 0 1 4
</code></pre></div></div>

<h2 id="예제-출력-1"><u>예제 출력 1</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5
</code></pre></div></div>

<h2 id="예제-입력-2"><u>예제 입력 2</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 8
3 1 2 3 4 1 1 2
</code></pre></div></div>

<h2 id="예제-출력-2"><u>예제 출력 2</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5
</code></pre></div></div>

<h2 id="예제-입력-3"><u>예제 입력 3</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 5
0 0 0 2 0
</code></pre></div></div>

<h2 id="예제-출력-3"><u>예제 출력 3</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
</code></pre></div></div>

<h2 id="풀이"><u>풀이</u></h2>

<p>목표는 고이는 빗물의 총량을 계산하기.</p>

<p>그렇다면 빗물이 언제, 어떻게 고이는 지를 파악하는 것이 포인트!</p>

<p>빗물은 언제 고이는가</p>

<ul>
  <li>특정 위치를 기준으로 좌우 방향에 각각 자신보다 더 높은 블록이 있을 때</li>
</ul>

<p>빗물이 어떻게 고이는가</p>

<ul>
  <li>좌우 방향에 각각 자신보다 더 높은 블록이 있을 때, 그 두 블록중에 작은 블록의 높이에 맞춰 고인다.</li>
</ul>

<p>규칙을 파악했으니 문제 풀이를 정리하면</p>

<ol>
  <li>현 위치에서 좌우에 자신보다 더 높은 블록이 있는지 체크한다.</li>
  <li>두 블록 중 더 작은 블록의 높이 <code class="language-plaintext highlighter-rouge">low</code>를 구한다.</li>
  <li>현 위치 블록의 높이를 <code class="language-plaintext highlighter-rouge">low</code>에 뺀다.</li>
  <li>그 값을 빗물의 총량을 나타내는 <code class="language-plaintext highlighter-rouge">water</code>에 더한다.</li>
  <li>오른쪽으로 위치를 이동한다.</li>
</ol>

<p>이를 2차원 세계의 맨 왼쪽과 오른쪽을 제외한, 빗물이 고일 수 있는 위치에서 한번씩 반복하면 빗물의 총량을 계산할 수 있다!</p>

<p>(맨 왼쪽과 오른쪽은 빗물이 고일 수 없다고 했으니 제외하는 것을 잊지 말아야 함!)</p>

<p>코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">ground</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
<span class="n">water</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ground</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
    
    <span class="n">low</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">:</span>
        <span class="n">water</span> <span class="o">+=</span> <span class="n">low</span> <span class="o">-</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
<span class="k">print</span><span class="p">(</span><span class="n">water</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>HE Tao</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2022-12-17-2022-11-13-JB6.html" rel="alternate" type="text/html" title="" /><published>2022-12-17T15:29:59+09:00</published><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/2022-11-13-JB6</id><content type="html" xml:base="http://localhost:4000/2022-12-17-2022-11-13-JB6.html"><![CDATA[<h1 id="백준-1로-만들기-1463번">[백준] 1로 만들기 #1463번</h1>

<p><a href="https://www.acmicpc.net/problem/1463">Link</a></p>

<h2 id="문제"><u>문제</u></h2>

<p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p>

<ol>
  <li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li>
  <li>X가 2로 나누어 떨어지면, 2로 나눈다.</li>
  <li>1을 뺀다.</li>
</ol>

<p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p>

<h2 id="입력"><u>입력</u></h2>

<p>첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.</p>

<h2 id="출력"><u>출력</u></h2>

<p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p>

<h2 id="예제-입력-1"><u>예제 입력 1</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
</code></pre></div></div>

<h2 id="예제-출력-1"><u>예제 출력 1</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
</code></pre></div></div>

<h2 id="예제-입력-2"><u>예제 입력 2</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10
</code></pre></div></div>

<h2 id="예제-출력-2"><u>예제 출력 2</u></h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3
</code></pre></div></div>

<h2 id="풀이"><u>풀이</u></h2>

<p>이 문제의 목표는 정수 N이 주어졌을 때, 위와 세 연산을 적절히 사용해서 1을 만드는데 필요한 연산 횟수의 최소값을 출력하는 문제이다.</p>

<p>최솟값.. 이런식으로 최소값을 구하는 문제는 내 경험에 의하면 푸는 방법이 두 가지로 나뉜다.</p>

<ul>
  <li>모든 경우의 수를 다 확인하여 최소값을 구하는 방식</li>
  <li>제한조건들로 인해 생기는 수의 패턴을 파악하고 이를 활용하여 최소값을 구하는 방식</li>
</ul>

<p>따라서 간단하게 생각하면 정수 N을 1로 만드는 모든 방법을 다 써본다음에 그때의 필요한 연산횟수의 최소값을 출력하여 문제를 풀 수 있어보인다.</p>

<p>(사실 생각하기는 간단하지만 구현하려고 하면 만만치 않아보인다.)</p>

<p>근데 여기서 다시 문제로 올라가보면 정수 N을 1로 만들기 위해 지켜야하는 엄격한 규칙이 무려 세 가지나 보인다.</p>

<p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p>

<ol>
  <li>
    <p>X가 3으로 나누어 떨어지면, 3으로 나눈다.</p>
  </li>
  <li>
    <p>X가 2로 나누어 떨어지면, 2로 나눈다.</p>
  </li>
  <li>
    <p>1을 뺀다.</p>
  </li>
</ol>

<p>이 조건들로 인해 생기는 정수 N의 따른 최소 연산 횟수에 어떤 패턴이 있을지 파악해보자.</p>

<p>먼저 1번 규칙, X가 3으로 나누어 떨어지면 3으로 나눈다.</p>

<p>즉, N=9면 3으로 나누고, N=6이면 3으로 나눈다라는 뜻이다.</p>

<p>그 다음 2번 규칙, X가 2로 나누어 떨어지면 2로 나눈다.</p>

<p>N=4면 2로 나누고, N=6이면 2로 나누라는 뜻이다.</p>

<p>여기서 혼란이 발생한다.</p>

<p>N=6일 때는 2로 나누어야할까 아니면 3으로 나누어야 할까?</p>

<p>정답은 바로 연산 횟수가 최소값이 되는 것으로 나누어야 한다는 것이다.</p>

<p>예시를 들자면 만약 N=24라고 했을 때, 24/2와 24/3중 연산 횟수를 최소값이 나오는 것으로 고르는 것이다.</p>

<p>즉 이는 과거의 값을 저장하여 나중에 사용하는 Dynamic programming 문제이다.</p>

<p>그럼 24/2와 24/3중 어떤게 최소값이 나오는지 알 수 있을까?</p>

<p>N=12, 24라고 하고, f를 연산횟수를 구하는 함수라고 하자. N=12일 때와 같은 방법으로 N=24을 1로 만든다고 가정하면 N=24일 때 연산횟수는 무엇인가?</p>

<p>바로 f(24/2) + 1이 된다. 24를 2로 나눈것이 12이기 때문에 이때의 연산 횟수는 단순하게 12를 1로 만드는 연산 횟수에 1을 더해주면 된다는 것이다.</p>

<p>이것을 똑같이 24를 3으로 나누는 것에 대해서도 적용하면 f(24/3) + 1이 연산횟수가 된다.</p>

<p>따라서 우리가 해야할 것은 f(24/2) + 1, f(24/3) + 1 중에서 더 작은 값을 알아내면 되는 것이다.</p>

<p>예외로 만약 2와 3으로 나누어떨어지지 않는 수는 어떤가?</p>

<p>3번 규칙에 따르면 N이 2와 3으로 나누어 떨어지지 않을 경우 1을 뺀다.</p>

<p>즉, 만약 N=13이라고 한다면 f(13) = f(12) + 1이 되는 것 이다.</p>

<p>위에서 찾은 모든 패턴을 코드로 구현하면 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">idx</span><span class="o">//</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
        
<span class="k">print</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
</code></pre></div></div>]]></content><author><name>HE Tao</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2022-12-17-2022-10-22-EJ3.html" rel="alternate" type="text/html" title="" /><published>2022-12-17T15:29:59+09:00</published><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/2022-10-22-EJ3</id><content type="html" xml:base="http://localhost:4000/2022-12-17-2022-10-22-EJ3.html"><![CDATA[<h1 id="2022-10-22-백준-돌게임1-9655md">2022-10-22-[백준]-돌게임1-#9655.md</h1>

<p>author. 곽은지</p>

<h2 id="문제">[문제]</h2>

<p>돌 게임은 두 명이서 즐기는 재밌는 게임이다.</p>

<p>탁자 위에 돌 N개가 있다. 상근이와 창영이는 턴을 번갈아가면서 돌을 가져가며, 돌은 1개 또는 3개 가져갈 수 있다. 마지막 돌을 가져가는 사람이 게임을 이기게 된다.</p>

<p>두 사람이 완벽하게 게임을 했을 때, 이기는 사람을 구하는 프로그램을 작성하시오. 게임은 상근이가 먼저 시작한다.</p>

<h3 id="입력">입력</h3>

<p>첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1000)</p>

<p>[예제입력]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span>
</code></pre></div></div>

<h3 id="출력">출력</h3>

<p>상근이가 게임을 이기면 SK를, 창영이가 게임을 이기면 CY을 출력한다.</p>

<p>[예제출력]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SK</span>
</code></pre></div></div>

<h2 id="풀이">[풀이]</h2>

<p>[핵심 아이디어]</p>

<ul>
  <li>오직 1개, 3개, 즉, 홀수 개수만큼만 가져갈 수 있기 때문에 홀수개는 먼저 시작한 상근이, 짝수개에서는 창영이가 이기게 된다.
    <ul>
      <li>1개 → 상근 // 2개 → 창영 // 3개 → 상근 // 4개 → 창영 // 5개 → 상근</li>
    </ul>
  </li>
</ul>

<p>[풀이 코드]</p>

<ol>
  <li>단순한 방법</li>
</ol>

<p>위의 개념을 코드로 구현한다면 다음과 같이 단순하게 구현 가능</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
 
<span class="k">if</span><span class="p">(</span><span class="n">N</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"CY"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"SK"</span><span class="p">)</span>
</code></pre></div></div>

<p>이처럼 단순 구현이 가능한 문제를 Dynamic Programming의 가장 중요한 과정인 ‘저장’ 과정을 사용해서 풀어보도록 하자.</p>

<ol>
  <li>dynamic programming 사용</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>  <span class="c1"># input
</span> 
<span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
 
<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
 
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
 
<span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'SK'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'CY'</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>미리 dp를 설정하고, 각 index에 각 사람에게 차례가 돌아오는 차례 횟수를 저장한다.
    <ul>
      <li>1개 → 상근(1) // 2개 → 상근, 창영(2) // 3개 → 상근(1) // 4개→ 상근, 창영(2)</li>
      <li>순서상 이전 차례에 +1 된 만큼 차례가 돌아옴</li>
    </ul>
  </li>
</ul>

<h2 id="things-that-you-can-get-from-this-problem"><strong>📌things that you can get from this problem</strong></h2>

<p><strong>동적 계획법(Dynamic programming)</strong>: 큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용하는 방법</p>

<ul>
  <li>동적 계획법에서 가장 중요한 개념은 ‘답을 저장’하는 것임</li>
  <li>답을 저장해서 새로운 case와 비교</li>
</ul>]]></content><author><name>HE Tao</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2022-12-17-2022-10-15-JB1.html" rel="alternate" type="text/html" title="" /><published>2022-12-17T15:29:59+09:00</published><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/2022-10-15-JB1</id><content type="html" xml:base="http://localhost:4000/2022-12-17-2022-10-15-JB1.html"><![CDATA[<h1 id="백준-쉬운-계단-수-10844번">[백준] 쉬운 계단 수 #10844번</h1>

<p><a href="https://www.acmicpc.net/problem/10844">Link</a></p>

<h2 id="문제"><u>문제</u></h2>

<p>45656이란 수를 보자.</p>

<p>이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.</p>

<p>N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.</p>

<h2 id="입력"><u>입력</u></h2>

<p>첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.</p>

<p>(N은 주어진 수의 자리 수를 의미한다.)</p>

<h2 id="출력"><u>출력</u></h2>

<p>첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.</p>

<h2 id="풀이"><u>풀이</u></h2>

<p>N의 자리수를 가진 수가 계단수를 가지는 경우의 수를 구하는 문제이다.</p>

<p>예를들어 N이 2라면 10 ~ 99 사이 계단수의 개수를 구해보면 아래와 같이 총 17개의 경우가 나온다.</p>

<table>
  <thead>
    <tr>
      <th>10</th>
      <th>12</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>21</td>
      <td>23</td>
    </tr>
    <tr>
      <td>32</td>
      <td>34</td>
    </tr>
    <tr>
      <td>43</td>
      <td>45</td>
    </tr>
    <tr>
      <td>54</td>
      <td>56</td>
    </tr>
    <tr>
      <td>65</td>
      <td>67</td>
    </tr>
    <tr>
      <td>76</td>
      <td>78</td>
    </tr>
    <tr>
      <td>87</td>
      <td>89</td>
    </tr>
    <tr>
      <td>98</td>
      <td>x</td>
    </tr>
  </tbody>
</table>

<p>​</p>

<table>
  <thead>
    <tr>
      <th>101</th>
      <th>121</th>
      <th>123</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>212</td>
      <td>210</td>
      <td>232</td>
      <td>234</td>
    </tr>
    <tr>
      <td>321</td>
      <td>323</td>
      <td>343</td>
      <td>345</td>
    </tr>
    <tr>
      <td>432</td>
      <td>434</td>
      <td>454</td>
      <td>456</td>
    </tr>
    <tr>
      <td>543</td>
      <td>545</td>
      <td>565</td>
      <td>567</td>
    </tr>
    <tr>
      <td>654</td>
      <td>656</td>
      <td>676</td>
      <td>678</td>
    </tr>
    <tr>
      <td>765</td>
      <td>767</td>
      <td>787</td>
      <td>789</td>
    </tr>
    <tr>
      <td>876</td>
      <td>878</td>
      <td>898</td>
      <td> </td>
    </tr>
    <tr>
      <td>987</td>
      <td>989</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>이를 바탕으로 유추한 규칙은 대강 아래와 같다.</p>

<ul>
  <li>N자리의 숫자가 0이면 (N+1)자리의 숫자는 1밖에 올 수 없다 -&gt; 경우의 수 1개</li>
  <li>N자리의 숫자가 9이면 (N+1)자리의 숫자는 8밖에 올 수 없다 -&gt; 경우의 수 1개</li>
  <li>위를 제외한 나머지 경우는 N자리의 숫자가 k라면 k+1, k-1이 올 수 있다 -&gt; 경우의 수 2개</li>
</ul>

<p>예를들어 N=2일 때 (N-1)자리의 숫자가 2라면 (21, 23)의 경우가 있다.</p>

<p>N=3이고 (N-2)자리의 숫자가 2일 경우에는 (212, 210, 232, 234)의 경우가 생긴다.</p>

<p>자리수 N의 상승하고 결국 (N-2)자리의 숫자가 2라면, (N-1)자리의 숫자가 1또는3 일 때의 경우의 수를 합한 것이 된다.</p>

<p>예외사항) (N-1)의 자리수가 0이라면 N의 자리수가 1, (N-1)의 자리수가 9라면 N의 자리수가 8인 경우만을 계산한다.</p>

<ul>
  <li>
    <p>자리수 표기: 123 -&gt; N자리 = 1, (N-1)자리 = 2, (N-2)자리 = 3</p>
  </li>
  <li>10 -&gt; 1 01</li>
  <li>21 -&gt; 2 10, 2 12</li>
  <li>23 -&gt; 2 32, 2 34</li>
  <li>89 -&gt; 8 98</li>
</ul>

<p>이를 수식으로 표현하면 아래와 같다.</p>

\[Cases[N][2] = Cases[N-1][1] + Cases[N-1][3] \\
Cases[N][0] = Cases[N-1][1] \\
Cases[N][9] = Cases[N-1][8]\]

<p>자리수 N을 층 또는 시간의 개념으로 바라본다면, 결국 이 문제는 과거에 구해논 값을 가지고 현재의 값을 결정하는 <strong>동적 프로그래밍 (Dynamic Programming)</strong> 문제라고 해석할 수 있다. (동적프로그래밍: 어떤 큰 문제를 풀기위해 그 문제를 더 작은 문제로 나누어서 푸는 기법)</p>

<p>그러면 이제 위에서 유추한 규칙과 동적 프로그래밍 패러다임을 적용하여 코드를 작성해보자</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>  <span class="c1"># Take input
</span><span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

<span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># 먼저 N=1 일 때의 경우를 예외처리
# 위 수식 참고
</span><span class="k">for</span> <span class="n">jary</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="c1"># 0과 9일 때의 예외처리
</span>    <span class="n">table</span><span class="p">[</span><span class="n">jary</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">jary</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">table</span><span class="p">[</span><span class="n">jary</span><span class="p">][</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">jary</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">namuji</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
        <span class="n">table</span><span class="p">[</span><span class="n">jary</span><span class="p">][</span><span class="n">namuji</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">jary</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">namuji</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">jary</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">namuji</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1000000000</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>HE Tao</name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/2022-12-17-2022-10-15-EJ1.html" rel="alternate" type="text/html" title="" /><published>2022-12-17T15:29:59+09:00</published><updated>2022-12-17T15:29:59+09:00</updated><id>http://localhost:4000/2022-10-15-EJ1</id><content type="html" xml:base="http://localhost:4000/2022-12-17-2022-10-15-EJ1.html"><![CDATA[<h1 id="백준no10844_쉬운계단수_python">[백준no.10844]_쉬운계단수_python</h1>

<h2 id="문제">문제</h2>

<p>45656이란 수를 보자.</p>

<p>이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.</p>

<p>세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.</p>

<p>N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)</p>

<h3 id="입력">입력</h3>

<p>첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.</p>

<p>[예제 입력]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>
</code></pre></div></div>

<h3 id="출력">출력</h3>

<p>첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다</p>

<p>[예제 출력]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">9</span>
</code></pre></div></div>

<h2 id="풀이">풀이</h2>

<p>[핵심 아이디어]</p>

<ul>
  <li>0~9까지의 숫자 중에서 각 숫자 앞 혹은 뒤에 올 수 있는 수의 개수는 각각 몇 개인지 따져봐야 함
    <ul>
      <li>옆에 올 수 있는 숫자의 수를 따져볼때, 0은 무조건 앞에 1 하나만 올 수 있고, 9 또한 앞에 8밖에 올 수 없음</li>
      <li>2~8까지 숫자는 앞 뒤로 +1, -1 숫자가 올 수 있음</li>
    </ul>
  </li>
</ul>

<p>[풀이코드]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>  <span class="c1">#행: 계단 길이(자릿수)
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>  <span class="c1">#열: 각 자릿수에서 올 수 있는 수
</span>        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#0일때는 1만
</span>        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span> <span class="c1">#9일때는 8만
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> 
<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1000000000</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>행렬을 활용하여 각 자릿 수에서의 경우의 수를 모두 합함</li>
</ul>

<h2 id="things-that-you-can-get-from-this-problem"><strong>📌things that you can get from this problem</strong></h2>

<p><strong>동적 계획법(Dynamic programming)</strong>: 큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용하는 방법</p>

<ul>
  <li>어떤 문제를 풀 때 작은 문제로 나누어서, 각각의 경우의 수를 구함</li>
  <li>해당 방법으로 풀 경우, 재사용(즉, 저장하고 재사용)이 가능하기 때문에 시간 복잡도 개선됨</li>
  <li>풀 수 있는 문제 유형:
    <ul>
      <li>부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 도출 ex)최적 경로</li>
      <li>동일한 작은 문제들이 반복 ex) 피보나치</li>
    </ul>
  </li>
</ul>]]></content><author><name>HE Tao</name></author></entry><entry><title type="html">2023-신기한-소수</title><link href="http://localhost:4000/jekyll/2022-12-16-EJ9.html" rel="alternate" type="text/html" title="2023-신기한-소수" /><published>2022-12-16T00:00:00+09:00</published><updated>2022-12-16T00:00:00+09:00</updated><id>http://localhost:4000/jekyll/EJ9</id><content type="html" xml:base="http://localhost:4000/jekyll/2022-12-16-EJ9.html"><![CDATA[<h1 id="2022-12-16-2023-신기한-소수">2022-12-16-#2023-신기한-소수</h1>

<p>challenge no.2</p>

<h1 id="문제">[문제]</h1>

<p>수빈이가 세상에서 가장 좋아하는 것은 소수이고, 취미는 소수를 가지고 노는 것이다. 요즘 수빈이가 가장 관심있어 하는 소수는 7331이다.</p>

<p>7331은 소수인데, 신기하게도 733도 소수이고, 73도 소수이고, 7도 소수이다. 즉, 왼쪽부터 1자리, 2자리, 3자리, 4자리 수 모두 소수이다! 수빈이는 이런 숫자를 신기한 소수라고 이름 붙였다.</p>

<p>수빈이는 N자리의 숫자 중에서 어떤 수들이 신기한 소수인지 궁금해졌다. N이 주어졌을 때, 수빈이를 위해 N자리 신기한 소수를 모두 찾아보자.</p>

<h1 id="입력">[입력]</h1>

<p>첫째 줄에 N(1 ≤ N ≤ 8)이 주어진다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span>
</code></pre></div></div>

<h1 id="출력">[출력]</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2333</span>
<span class="mi">2339</span>
<span class="mi">2393</span>
<span class="mi">2399</span>
<span class="mi">2939</span>
<span class="mi">3119</span>
<span class="mi">3137</span>
<span class="mi">3733</span>
<span class="mi">3739</span>
<span class="mi">3793</span>
<span class="mi">3797</span>
<span class="mi">5939</span>
<span class="mi">7193</span>
<span class="mi">7331</span>
<span class="mi">7333</span>
<span class="mi">7393</span>
</code></pre></div></div>

<h1 id="풀이">[풀이]</h1>

<p>문제를 보고 가장 먼저 떠오른 풀이 방식</p>

<ol>
  <li>소수 구하기</li>
  <li>그 다음에 n의 자릿수 만큼 조합하기</li>
</ol>

<p>이 문제의 핵심은 소수를 어떻게 구할 것인지 !</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_lst</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">prime_num</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">%</span> <span class="n">i</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1">#자기 자신까지 숫자로 나누었을때 나눠떨어진다면 -&gt; 소수아님
</span>        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
         <span class="n">num_lst</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">#나머지는 소수임(2포함)
</span><span class="k">return</span> <span class="n">num_lst</span>
</code></pre></div></div>

<p>이 방식으로 풀면 시간복잡도가 크기 때문에 백준을 돌려도 통하지 않는다 !</p>

<p>그래서 보통 소수를 구할때 사용하는 방법 !</p>

<p>바로 “””에라토스테네스의 체””””</p>

<p>→ 입력받은 숫자까지 2이상으로 차례로 나열한 뒤</p>

<p>제곱해서 자신이 되는 수까지 차례대로 나누어서 나머지가 0이 되는 수들을 차례대로 삭제</p>

<p>→ 혼자서 코드로 구현하려고 시도했지만 … 장렬히 실패 …</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">primes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">toss</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
         <span class="n">primes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
              <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">primes</span>
</code></pre></div></div>

<p>이를 통해 소수를 찾는 문제는 해결이 되었고,</p>

<p>이를 이용하여 n의 자리 수까지 소수인지를 탐색하는 함수를 만들면 문제 해결 !</p>

<p>→ 문제 유형 : DFS(재귀함수 or Stack)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">strnum</span><span class="p">):</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strnum</span><span class="p">)</span> <span class="o">==</span><span class="n">N</span><span class="p">:</span>
		<span class="k">print</span><span class="p">(</span><span class="n">strnum</span><span class="p">)</span>
		<span class="k">return</span>
	
	<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
		<span class="n">newnum</span> <span class="o">=</span><span class="n">strnum</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">toss</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">newnums</span><span class="p">)):</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">newnum</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>EUNJI KWAK</name></author><category term="Jekyll" /><summary type="html"><![CDATA[2022-12-16-#2023-신기한-소수]]></summary></entry><entry><title type="html">3584-가장 가까운 공통 조상</title><link href="http://localhost:4000/jekyll/2022-12-13-EJ8.html" rel="alternate" type="text/html" title="3584-가장 가까운 공통 조상" /><published>2022-12-13T00:00:00+09:00</published><updated>2022-12-13T00:00:00+09:00</updated><id>http://localhost:4000/jekyll/EJ8</id><content type="html" xml:base="http://localhost:4000/jekyll/2022-12-13-EJ8.html"><![CDATA[<h1 id="2022-12-13-3584-가장-가까운-공통-조상">2022-12-13-#3584-가장 가까운 공통 조상</h1>

<h1 id="문제">[문제]</h1>

<p>루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Anscestor)은 다음과 같이 정의됩니다.</p>

<ul>
  <li>두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.</li>
</ul>

<p><img src="2022-12-13-#3584-%E1%84%80%E1%85%A1%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%A1%E1%84%81%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%90%E1%85%A9%E1%86%BC%20%E1%84%8C%E1%85%A9%E1%84%89%E1%85%A1%E1%86%BC%208f253df29c69489eafefedc2281e08ad/Untitled.png" alt="Untitled" /></p>

<p>예를 들어  15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.</p>

<p>루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요</p>

<h1 id="입력">[입력]</h1>

<p>첫 줄에 테스트 케이스의 개수 T가 주어집니다.</p>

<p>각 테스트 케이스마다, 첫째 줄에 트리를 구성하는 노드의 수 N이 주어집니다. (2 ≤ N ≤ 10,000)</p>

<p>그리고 그 다음 N-1개의 줄에 트리를 구성하는 간선 정보가 주어집니다. 한 간선 당 한 줄에 두 개의 숫자 A B 가 순서대로 주어지는데, 이는 A가 B의 부모라는 뜻입니다. (당연히 정점이 N개인 트리는 항상 N-1개의 간선으로 이루어집니다!) A와 B는 1 이상 N 이하의 정수로 이름 붙여집니다.</p>

<p>테스트 케이스의 마지막 줄에 가장 가까운 공통 조상을 구할 두 노드가 주어집니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="c1">#테스트 케이스의 개수
</span><span class="mi">16</span> <span class="c1">#트리를 구성하는 노드의 수
</span><span class="mi">1</span> <span class="mi">14</span> <span class="c1">#1이 14의 부모
</span><span class="mi">8</span> <span class="mi">5</span>
<span class="mi">10</span> <span class="mi">16</span>
<span class="mi">5</span> <span class="mi">9</span>
<span class="mi">4</span> <span class="mi">6</span>
<span class="mi">8</span> <span class="mi">4</span>
<span class="mi">4</span> <span class="mi">10</span>
<span class="mi">1</span> <span class="mi">13</span>
<span class="mi">6</span> <span class="mi">15</span>
<span class="mi">10</span> <span class="mi">11</span>
<span class="mi">6</span> <span class="mi">7</span>
<span class="mi">10</span> <span class="mi">2</span>
<span class="mi">16</span> <span class="mi">3</span>
<span class="mi">8</span> <span class="mi">1</span>
<span class="mi">16</span> <span class="mi">12</span>
<span class="mi">16</span> <span class="mi">7</span>
<span class="mi">5</span>
<span class="mi">2</span> <span class="mi">3</span>
<span class="mi">3</span> <span class="mi">4</span>
<span class="mi">3</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="mi">5</span>
<span class="mi">3</span> <span class="mi">5</span> <span class="c1">#3과 5의 공통 조상을 구하여라
</span></code></pre></div></div>

<h1 id="출력">[출력]</h1>

<p>각 테스트 케이스 별로, 첫 줄에 입력에서 주어진 두 노드의 가장 가까운 공통 조상을 출력합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span>
<span class="mi">3</span>
</code></pre></div></div>

<h1 id="풀이">[풀이]</h1>

<ul>
  <li>처음에는 연결 노드를 만들 생각을 했지만 .. 이 문제의 취지와 맞지 않음</li>
  <li>부모노드 만들기</li>
  <li>트리 만들기</li>
  <li>탐색 알고리즘 만들기</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="c1">#부모노드 만들기
</span>        <span class="n">parents</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">a_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span>
    <span class="n">b_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>

<span class="c1">#트리 추가   
</span>    <span class="k">while</span> <span class="n">parents</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
        <span class="n">a_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
        <span class="n">b_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
   
<span class="c1">#뒤에서부터 탐색 
</span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">a_list</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b_list</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="n">a_list</span><span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<h1 id="배운점">[배운점]</h1>

<ul>
  <li>좀 돌아갔지만, , 트리구조를 직접 구현할 수 있었음</li>
</ul>]]></content><author><name>EUNJI KWAK</name></author><category term="Jekyll" /><summary type="html"><![CDATA[2022-12-13-#3584-가장 가까운 공통 조상]]></summary></entry><entry><title type="html">14719. 빗물</title><link href="http://localhost:4000/jekyll/2022-12-09-MJ9.html" rel="alternate" type="text/html" title="14719. 빗물" /><published>2022-12-09T00:00:00+09:00</published><updated>2022-12-09T00:00:00+09:00</updated><id>http://localhost:4000/jekyll/MJ9</id><content type="html" xml:base="http://localhost:4000/jekyll/2022-12-09-MJ9.html"><![CDATA[<h1 id="14719-빗물">#14719. 빗물</h1>

<h2 id="use_math-true">use_math: true</h2>

<h3 id="링크-httpswwwacmicpcnetproblem14719">링크: https://www.acmicpc.net/problem/14719</h3>
<h3 id="유형-시뮬레이션">유형: 시뮬레이션</h3>
<h3 id="작성일시-2022년-12월-9일-오전-1147">작성일시: 2022년 12월 9일 오전 11:47</h3>

<h1 id="문제">📖문제</h1>

<p>2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.</p>

<p><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/1.png" alt="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/1.png" /></p>

<p><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/2.png" alt="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/2.png" /></p>

<p>비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?</p>

<p><strong>입력</strong></p>

<p>첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)</p>

<p>두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.</p>

<p><strong>출력</strong></p>

<p>2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.</p>

<p>빗물이 전혀 고이지 않을 경우 0을 출력하여라.</p>

<p><strong>예제 입력1  /출력 1</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="mi">4</span>
<span class="mi">3</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">4</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span>
</code></pre></div></div>

<p><img src="#14719%20%E1%84%87%E1%85%B5%E1%86%BA%E1%84%86%E1%85%AE%E1%86%AF%205c2a6ec0d85f485882405cd2d69b867a/Untitled.png" alt="Untitled" /></p>

<p><strong>예제입력 2 / 출력 2</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="mi">8</span>
<span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span>
</code></pre></div></div>

<p><img src="#14719%20%E1%84%87%E1%85%B5%E1%86%BA%E1%84%86%E1%85%AE%E1%86%AF%205c2a6ec0d85f485882405cd2d69b867a/Untitled%201.png" alt="Untitled" /></p>

<p>**예제 입력 3 / 출력 3 **</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="mi">5</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">0</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span>
</code></pre></div></div>

<p><img src="#14719%20%E1%84%87%E1%85%B5%E1%86%BA%E1%84%86%E1%85%AE%E1%86%AF%205c2a6ec0d85f485882405cd2d69b867a/Untitled%202.png" alt="Untitled" /></p>

<h1 id="분석">🧐분석</h1>

<h2 id="유형-파악">👀유형 파악</h2>

<p>이러한 문제 유형을 <strong>‘구현’문제</strong>라고 한다.</p>

<aside>
📢  ‘구현(Implementation)’이란, **머리 속에 있는 알고리즘을 소스코드로 바꾸는 과정’**을 의미한다.

</aside>

<h3 id="구현문제">구현문제</h3>

<ul>
  <li><strong>풀이를 떠올리는 것은 쉽지만, 소스코드로 옮기기 어려운 문제</strong>
    <ul>
      <li>코딩 테스트에서는 <strong>구현이 중심이 되는 문제가 자주 출제</strong>된다</li>
      <li>ex) 완전탐색, 시뮬레이션 유형
        <ul>
          <li><strong>완전탐색</strong> : 모든 경우의 수를 주저 없이 다 계산하는 해결방법</li>
          <li><strong>시뮬레이션</strong> : 문제에서 제시한 알고리즘을 <strong>한 단계씩 차례대로 직접 수행</strong>해야 하는 문제</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>구현하기 어려운 문제란?</strong></p>

<ul>
  <li><strong>알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제</strong></li>
  <li>특정 소수점 자리까지 출력해야 하는 문제</li>
  <li>문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 파싱해야 하는 문제</li>
</ul>

<p>⇒ 대체로 사소한 조건 설정이 많은 문제일수록 코드로 구현하기 까다롭다.</p>

<p><strong>구현 문제를 풀기 위한 선행 조건</strong></p>

<ol>
  <li>프로그래밍 문법의 정확한 숙지</li>
  <li>라이브러리 사용경험</li>
</ol>

<p><strong>구현 문제에 접근하는 방법</strong></p>

<ul>
  <li>보통 구현 유형의 문제는 사소한 입력 조건 등을 문제에서 명시하여 <strong>문제의 길이가 꽤 긴 편</strong>이다.
    <ul>
      <li>하지만, 고차원적 사료적을 요구하는 문제는 나오지 않는 편이라 <strong>문법에 익숙하면 오히려 쉽게 풀 수 있다.</strong></li>
    </ul>
  </li>
  <li><strong>C/C++/Java에서 구현 유형 문제</strong>가 더 어렵게 다가온다.
    <ul>
      <li>문자열을 처리하거나 큰 정수를 처리하는 문제가 출제되는 경우가 많은데 C/C++/JAVA에서는 문자열 처리가 파이썬에 비하여 까다롭고, 큰 정수를 처리하는 라이브러리를 별도로 사용하기 때문이다.</li>
      <li>자신만의 코드 노트를 잘 활용하여 이를 보완할 수 있다.</li>
    </ul>
  </li>
</ul>

<p>출처 : <a href="https://scshim.tistory.com/431">[Algorithm] 구현 문제란?</a></p>

<h2 id="문제-분석">🔍문제 분석!</h2>

<ol>
  <li><strong>물이 고이는 조건을 찾자</strong>
    <ul>
      <li>양 옆이 모두 벽이 있어야 한다.</li>
      <li>어느 한 구간이 아니라 현재 위치에서 왼쪽, 오른쪽을 다 봐야 한다!</li>
    </ul>
  </li>
  <li>
    <p><strong>모듈화를 해보자</strong></p>

    <p><img src="https://user-images.githubusercontent.com/101111603/206859803-79febde6-02b1-4e0a-999c-8545897f7340.jpg" alt="%EB%AA%A8%EB%93%88" /></p>
  </li>
  <li><strong>정답</strong></li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">height</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">ground</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
<span class="n">rain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># for문을 통해서 양 옆 비교하기
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">std</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">std</span><span class="p">:</span>
        <span class="n">rain</span> <span class="o">+=</span> <span class="n">std</span> <span class="o">-</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># 값 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">rain</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="풀이과정">🎯풀이과정</h1>

<p>최종 답안은 맨 아래에 있습니다.</p>

<h3 id="1번째-시도">1번째 시도</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">#세로 : height 가로 :weight
# 입력받기
</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">ground</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
<span class="c1">#양옆 비교
</span>	<span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span> <span class="p">[:</span><span class="n">i</span><span class="p">])</span>
	<span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

	<span class="k">if</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">:</span>
		<span class="n">rain</span><span class="o">+=</span> <span class="n">left</span> <span class="o">-</span> <span class="n">ground</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="k">if</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
		<span class="n">rain</span><span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">ground</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="c1">#값 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">rain</span><span class="p">)</span>
</code></pre></div></div>

<p>🚨이 코드의 문제점 : 이중으로 더해진다!</p>

<h3 id="3번째-시도">3번째 시도</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#세로 : height 가로 :weight
# 입력받기
</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">ground</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
<span class="n">rain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="p">:</span>
<span class="c1">#양옆 비교
</span>	<span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span> <span class="p">[:</span><span class="n">i</span><span class="p">])</span>
	<span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
	<span class="n">std</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">std</span><span class="p">:</span>
		<span class="n">rain</span><span class="o">+=</span> <span class="n">std</span><span class="o">-</span> <span class="n">ground</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">NameError: name 'rain' is not defined</code></p>

<p><code class="language-plaintext highlighter-rouge">ValueError: max() arg is an empty sequence</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Name error</code> → rain을 0으로 초기화해줌</li>
  <li><code class="language-plaintext highlighter-rouge">Value error</code> → 수치를 비교할 수 있는 데이터가 존재하지 않는 빈 리스트를 제공할 때 발생하는 에러이다. 리스트가 빈 리스트인지 확인하거나 len() 명령어를 통해 리스트 요소의 개수를 확인한 다음 작업을 수행하게 하면 코드가 아무 문제없이 정상 작동하는 것을 확인할 수 있다.</li>
</ul>

<p>⇒ <strong>해결 : for문의 범위 설정이 잘못 되었음!
왜냐하면, 맨 왼쪽과 맨 오른쪽은 물이 고일 수 없기 때문에 그 부분은 제외하고 탐색해야 함</strong></p>

<p>따라서 <code class="language-plaintext highlighter-rouge">**for i in range(1, weight-1)**</code>로 변경!</p>

<h3 id="3번째-시도--for문의-범위-수정">3번째 시도 : for문의 범위 수정</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weight</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">ground</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
<span class="n">rain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># for문을 통해서 양 옆 비교하기
</span> 
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">std</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
 
    <span class="k">if</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">std</span><span class="p">:</span>
        <span class="n">rain</span> <span class="o">+=</span> <span class="n">std</span> <span class="o">-</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
 
<span class="c1"># 값 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">rain</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>🚨값이 제대로 안 나오고, 백준에서도 틀렸다고 나옴</strong></p>

<p>⇒ 왜지?!</p>

<p>⇒ for범위에서 weight-1은 맞다.근데 입력 받을 때 weight, height 순으로 받았기 때문에 4, 8 에서 4가 들어가기 때문이다</p>

<h3 id="최종--입력값-위치-수정">최종 : 입력값 위치 수정</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 입력
</span><span class="n">height</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="n">ground</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>
<span class="n">rain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># for문을 통해서 양 옆 비교하기
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">std</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">std</span><span class="p">:</span>
        <span class="n">rain</span> <span class="o">+=</span> <span class="n">std</span> <span class="o">-</span> <span class="n">ground</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># 값 출력
</span><span class="k">print</span><span class="p">(</span><span class="n">rain</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="결과"><strong>결과</strong></h3>
<p><img src="https://user-images.githubusercontent.com/101111603/206859812-5b6728f6-2a76-4b02-88e0-90b40cd20382.JPG" alt="python" /></p>

<h1 id="회고">✒회고</h1>

<ul>
  <li>매번 ‘이걸 어떻게 코드로 구현하지?’ 하고 얘기하는데, 시뮬레이션 문제가 있다는 것을 오늘을 계기로 알게 되었다.
    <ul>
      <li>실제로 삼성, 카카오 등에서 코딩테스트 문제로 시뮬레이션 문제를 많이 낸다고 한다!</li>
      <li>시뮬레이션 문제란, 풀이를 떠올리는 건 쉽지만, 구현하는 것은 어려운 문제를 말한다!! 이번에 이렇게 배워간다~~</li>
    </ul>
  </li>
  <li>빗물 문제도 그냥 보기에는 어떻게 풀어야 할지 알겠는데 코드로 구현하자니 조건을 어떻게 설정해야 할지 막막했다.</li>
  <li>이럴 때는 역시나 다른 문제들을 푸는 것처럼 하나하나 식으로 풀거나 그림을 그린 후 규칙성이나 점화식을 만들어낸 뒤!
컴퓨터의 입장에서 조건이 무엇일지 생각해보는 방식으로 하면 좋을 것 같다!</li>
  <li>매번 스터디에서 다들 2시간~3시간 사이의 시간이 걸렸는데 오늘은 딱 1시간만에 끝났다! 그간 다들 실력이 는 것 같다</li>
</ul>]]></content><author><name>MINJUNG KIM</name></author><category term="Jekyll" /><summary type="html"><![CDATA[#14719. 빗물]]></summary></entry></feed>