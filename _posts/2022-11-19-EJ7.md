---
title: BOJ-12865.평범한-배낭
author: EUNJI KWAK
date: 2022-11-19
categories: [BaekJoon, EUNJI_B]
tags: [dp]
---

# 2022-11-19-#12865-평범한-배낭

# [문제]

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 떄문에, 가지고 다닐 배날 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건은 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

# [입력]

첫 줄에 물품의 수 N(1≤ N ≤ 100)과 준서가 버틸 수 있는 무게(1≤ K ≤ 100, 000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1≤ W ≤ 100, 000)와 해당 물건의 가치 V(0≤ V ≤ 1,000)가 주어진다. 

입력으로 주어지는 모든 수는 점수이다. 

```c
4 7 
6 13
4 8
3 6
5 12
```

# [출력]

한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다. 

```c
14
```

# [풀이]

주어진 조건 내에서 최댓값(or 최솟값) 구하기

이 대목에서 당신이 어떤 냄새를 맡았다면 그동안 해왔던 알고리즘 공부가 헛되지 않았음을 의미한다. (힘내시오 .. 용사여 ..)

이 냄새에 대한 출처는 바로 “””동적 프로그래밍”””이다.

이 문제를 보면 지난번에 풀었던 ‘연산자 끼워넣기(#14888)’문제와 동일하게 동적 프로그래밍으로 풀 수 있는 문제이다.

그리고 동적 프로그래밍 문제를 풀 때 우리는 dp table을 사용하게 될 것이라는 것을 미리 알고 문제 풀면 훨씬 산뜻한 시작이 될 것이다!

table을 만들때 가장 먼저 들어야 하는 생각이 3가지 있다.

1. 행은 무엇을 의미
2. 열은 무엇을 의미
3. 표 안의 값을 무엇을 의미

이렇게 3가지를 나눠서 생각하기까지에 이르면 당신은 어느정도 nirvana에 오른 것과 다름 없다. 축하한다.

1. 행은 무엇을 의미

→ 이 문제에서는 최대 물건의 개수로 하자.

1. 열은 무엇을 의미

→ product[i][j]로 둘 때, 각 행과 열에 물건의 무게와 물건 가치를 두자.

1. 표 안의 값은 무엇을 의미

→ 이 문제의 최종 출력은 ‘배낭에 넣을 수 있는 물건의 가치합의 최댓값’이므로 물건의 ‘’가치’’를 저장하도록 하자.

이를 바탕으로 한 표는 다음과 같다.

|  |  | i (순서)  / j(무게) | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| product[i] | product[j] | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 6 (무게) | 13 (가치) | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 13 |
| 4 | 8 | 2 | 0 | 0 | 0 | 0 | 0 |  |  |
| 3 | 6 | 3 | 0 | 0 | 0 | 6 |  |  |  |
| 5 | 12 | 4 | 0 | 0 | 0 | 0 | 0 | 12 |  |

### 만든 표를 바탕으로 코드로 나타내보자.

```c
n, k = map(int, input().split()) #물품의 수, 최대 무게

thing = [[0, 0]]  #[무게, 가치]
bag = [[0]* (k+1) for _ in range(n+1)]  #[순서(thing의 index를 불러오는), 최대 무게]

for i in range(n):
  thing.append(list(map(int, input().split())))

for i in range(1, n+1):
  for j in range(1, k+1):
    weight = thing[i][0]
    value = thing[i][1]

    if j - weight >= 0:
      bag[i][j] = max(bag[i-1][j], bag[i-1][j-weight]+value)
    else:
      bag[i][j] = bag[i-1][j]
```
