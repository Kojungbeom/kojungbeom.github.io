---
title: 프로그래머스 - 등굣길
author: JUNGBEOM KO
date: 2023-2-10
categories: [Programmers, JUNGBEOM_P]
tags: [Programmers, JUNGBEOM, DP]
---

# [프로그래머스] 등굣길

[Link](https://school.programmers.co.kr/learn/courses/30/lessons/42898)



## 문제

계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.

가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.

격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. **오른쪽과 아래쪽으로만 움직여** 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.

##### 제한사항

- 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
  - m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
- 물에 잠긴 지역은 0개 이상 10개 이하입니다.
- 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.



## 입출력 예

| m    | n    | puddles  | return |
| ---- | ---- | -------- | ------ |
| 4    | 3    | [[2, 2]] | 4      |



## 풀이

출발지점에서 출발 -> 지나온 길을 기록하며 몇번만에 도착지점에 왔는지 기록 -> 모든 valid한 길에 대해 반복

하면 풀 수 있는 문제일 것 이다 (아마도?).

근데 생각만해도 코딩하기 상당히 복잡하고, 구현을 했다고해도 그리 효율적인 알고리즘은 아닐 것이다.

모든 길을 반복해서 봐야하기 때문이다.

이렇게 해보면 어떨까?

- 문제를 분할하여 생각한다. -> 출발지점에서 도착지점으로 가는게 아니라 현재 지점에서 오른쪽, 또는 아래로 이동하는 문제로 분할
- 출발지점으로부터 어떤 지점에 도착하는최소 경로의 개수는 기록

이렇게 한다면 이전에 계산했던 부분은 다시 계산할 필요가 없다.

그리고 어떤 지점에 도착하는 최소개수는 이전 왼쪽과 위쪽 지점의 최소 경로를 더한 것이 된다.

즉, 이 문제는 DP를 활용하여 풀면 좋을 문제라고 할 수 있다!

내가 생각하는 알고리즘을 테이블로 표현해보면 아래와 같다.

| 출발 (1) | 1    | 1    | 1        |
| -------- | ---- | ---- | -------- |
| 1        | 퍼들 | 1    | 2        |
| 1        | 1    | 2    | 도착 (4) |

점화식으로 바꿔보면 아래와 같다.

| dp[1,1]           | dp[1,1] + d[0,2]         | dp[1,2] + dp[0,3] | dp[1,3] + dp[0,4] |
| ----------------- | ------------------------ | ----------------- | ----------------- |
| dp[1,1] + dp[2,0] | 퍼들 (dp[1,2] + dp[2,1]) | dp[1,3] + dp[2,2] | dp[1,4] + dp[2,3] |
| dp[2,1] + dp[3,0] | dp[2,2] + dp[3,1]        | dp[2,3] + dp[3,2] | dp[2,4] + dp[3,3] |

이제 퍼들을 만났을 때의 예외처리만 넣어서 코드로 작성하면 아래와 같다.

```python
def solution(m, n, puddles):
    dp = [[0] * (m + 1) for i in range(n + 1)]
    dp[1][1] = 1
    puddles.append([1,1])
    for i in range(1, n+1):
        for j in range(1, m+1):
            if [j,i] in puddles:
                continue
            dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[n][m] % 1000000007
```

